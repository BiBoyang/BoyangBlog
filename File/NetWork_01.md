# 伯阳的网络笔记（二）：HTTP基础
> 因为疫情期间在外当志愿者，晚上回家无聊翻翻网络知识，权当记录了。
> 初始动笔：2019-02-03
> 修改时间：2019-03-20

#### 网络分层
我们都知道，互联网是一个极其复杂的体系，包含了大量的应用程序和协议、各种类型的端系统、分组交换机和各种类型的链路级媒体。为了将这些整理，我们将整个网路进行了抽象分层。

关于分层，其实有很多种分法，我们一般接受两种：**TCP / IP分层**和**OSI分层**。分别如下表示。

![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_02.png?raw=true)

实际上为了简便（~~以及我本身就是客户端开发~~），大家一般只记住五层就可以了。

上文讲的 DNS 工作在应用层。

# 0. HTTP 前传

作为一个iOS开发，这里先讲一个故事。

乔布斯在被苹果赶走没多久后成立了一家电脑公司--NeXT计算机公司。NeXT在1988年推出了第一个工作站计算机产品NeXT Computer，大出风头（但是却没卖出去多少台，实在是太贵了）。但是它的面向对象操作系统--NeXTSTEP缺留下了深远的影响，iOS开发中NS开头的API就是源于此。

没过多久，在欧洲核子研究中心工作的一个名叫Emilio Pagiola忽悠来经费，买了当时研究所的第一台NeXT计算机。这可是个时髦的玩意啊，那里的科学家纷纷前来把玩。在围观的程序员里，有个叫做 Tim Berners-Lee 的科学家，他不仅把玩了计算机，还开始研究起了当时还算时髦的 Objective-C，并打算解决文本传输的问题。

而在1990年，Tim Berners-Lee 成功的搭建了实际上第一个 HTTP 服务器和浏览器，然后给他起了一个伟大的名字-- **World Wide Web**。

# 1. HTTP历史
讲完上面那个故事，大家实际上也明白 HTTP 被创造的原因了--我们需要可靠的传输文本的协议。

**HTTP** 是 **HyperText Transfer Protocol**的缩写，翻译过来时**超文本传输协议**。
> 实际上更严谨的说法是 超文本转移协议，但是大家都这么说了，也就这么说了。

最开始的 HTTP 并不完善，被称之为 HTTP/0.9。到了1996年5月，版本更新为1.0，记载于[RFC1945: Hypertext Transfer Protocol -- HTTP/1.0](https://tools.ietf.org/html/rfc1945).
然后在1997年1月，公布了当前应用最广泛的 HTTP/1.1 ，记载于[RFC2616:Hypertext Transfer Protocol -- HTTP/1.1](https://tools.ietf.org/html/rfc2616)。
在2015年5月，HTTP/2 被公布，记载于[RFC7540](https://tools.ietf.org/html/rfc7540)。
而基于 QUIC 的 HTTP/3 的标准正在慢慢尝试中，现在可以在 Chrome 中尝试，可以查看[这篇文章](https://quicwg.org/base-drafts/draft-ietf-quic-http.html)查看关于HTTP/3的一些事情。


## 2. HTTP 基础
HTTP 是一个应用层协议，使用 TCP 来作为它的传输协议，而非 UDP。HTTP 会先发出一个和服务器的 TCP 连接，一旦连接建立，该客户端就可以和服务器进行传输。TCP 为 HTTP 提供了可靠数据传输服务，服务器发出的每个 HTTP 响应报文都可以最终**完整**的到达客户端；反之亦然。

HTTP/1 并不存储任何关于客户端的状态信息。假如某个特定的客户短短的几秒内请求了几十次同一个对象，服务器并不会因为刚刚提供了该对象就不再反应，而是每次都重新发送该对象，就像完全不记得之前做过的事一样。所以，我们可以说，HTTP 是**无状态的协议**。但是后来为了保存状态，在[RFC6265](https://tools.ietf.org/html/rfc6265)中定义了 Cookie。


而 HTTP 有两种连接方法：**非持续连接**和**持续连接**。

非持续连接每次请求完数据之后，TCP 连接就会关闭。这样的缺点显而易见，
1. 每次请求都要重新进行 TCP 三次握手，会浪费很多 RTT（Round-Trip Time，往返时间）；
2. 每次 TCP 连接，都需要在客户端和服务器上分配 TCP 缓冲区，这会带来非常多的不必要的负担。

所以说，我们一般采用持续连接的方式来解决这个问题。在 TCP 连接上之后，会经过一段超时时间（可配置的超时间隔）之后，HTTP 服务器再将它关闭。

# 3. HTTP 报文结构
![]()
报文结构如图所示。

从客户端发往服务器的是**请求报文（request message）**，从服务器发往客户端的是**响应报文（response message）**。
HTTP 报文包含三个部分：
1. 起始行 
        报文的第一行就是起始行，在请求报文中用来说明要做什么。
2. 首部字段
        起始行之后可能会有零个或者多个首部字段。每个首部字段都包含一个名字和一个值，以便于解析，二者用冒号分割。
3. 主体
        包含所有类型的数据。请求主体中包括了要发给服务器的数据，以及服务器要返回给客户端的数据。

通用的首部字段如下，还有更多的，直接搜索就好，很少有人会把这些东西都背下来。

| 首部 | 描述 | 
| :---: | :---: |
|Cache-Control|控制缓存的行为，用于随报文传送缓存的指示|
|Connection| 允许客户端和服务器指定与请求/响应连接有关的选项| 
|Date| 提供日期和时间标志，说明报文是什么时间创建的 |
|Pragma|报文指令，另一种随报文传送指示的方式，但并不专用于缓存。Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。如果想要所有的服务器保持相同的行为，可以考虑发送 Pragma 指令。例如：Pragma: no-cache Cache-Control: no-cache|
|MIME-Version |给出了发送端使用的 MIME 版本 |
|Trailer| 如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合 |
|Transfer- Encoding |告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 |
|Update| 给出了发送端可能想要 “升级” 使用的新版本或协议|
|Via |显示了报文经过的中间节点（代理、网关）|
|Warning| 错误通知|

# 4。 HTTP 状态码
服务器返回的  **响应报文**  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

而伴随每个状态码，HTTP还会发送一条解释性的原因短语。










# 引用
[HTTP 基础概述](https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP.md)

《图解 HTTP》

《HTTP 权威指南》

《计算机网络：自顶向下方法》