# 第12章 并发编程
CSAPP读书笔记(缩水版)

## 什么是并发？
可以理解为逻辑控制流在同一时间上重叠；也可以理解为同时发生多个事件。
在以下的情况下是非常有用的：
> * 访问慢速I/O设备
> * 与人交互
> * 通过推迟工作以降低延迟
> * 服务多个网络客户端
> * 在多核机器上进行并行运算

使用应用级并发的应用程序被称为并发程序（concurrent program）。现在操作系统提供了三种基本的构造并发程序的方法：
  
 * **进程**      
    每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信（IPC）机制。
 * **I/O多路复用**     
    应用程序在一个进程的上下文中显式的调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式的从一个状态换到另一个状态。因为程序是一个单独的进程，所以所有的流共享一个地址空间。
 * **线程**      
    线程是运行在一个单一进程上下文中的逻辑流，由内核调度。线程像进程流一样由内核调度，像I/O复用流一样共享同一个虚拟地址空间。
    

## 基于进程的并发编程
   
 构造并发程序的最简单方法就是使用进程，比如fork、exec、waitpid函数。
 代码如下：
 
 ```C++
 
void sigchld_handler(int sig){
    while (waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
    // Reap all zombie children
}

int main(int argc, char **argv) {
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    
    Signal(SIGCHLD, sigchld_handler);
    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        if (Fork() == 0) {
            Close(listenfd); // Child closes its listening socket
            echo(connfd); // Child services client
            Close(connfd); // Child closes connection with client
            exit(0); // Child exits
        }
        Close(connfd); // Parent closes connected socket (important!)
    }
}
 ```
在这里有几点要注意：

* 每个客户端由独立子进程处理
* 需要回收多个僵死子进程，来回收资源
* 需要父子进程关闭connfd副本，以免内存泄漏
* 内核会保存每个 socket 的引用计数，在 fork 之后 refcnt(connfd) = 2，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零
* 不同进程之间不共享数据，有独立的地址空间；这也导致有可能一个进程不小心覆盖另外一个进程的虚拟内存
* 进程共享状态信息变得更加困难，为了共享信息，必须使用显示的IPC机制。

## 基于I/O多路复用的并发编程
使用select挂起进程，当一个或者多个I/O事件发生后，才将控制返回给应用程序。	
一个明显的优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另外，一个基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。
当然，最事件驱动的一个明显的缺点就是编码变得复杂。

## 基于线程的并发编程
线程是运行在进程上下文中的逻辑流。	
线程由内核自动调度，每个线程都有它自己的线程上下文（thread context），包括一个唯一的线程ID、栈、指针、栈指针、程序计数器、通用目的寄存器和条件码。	
所有的运行在一个进程里的线程共享这个进程的虚拟地址空间。
每个进程开始生命周期的时候都是单一线程，这个线程称为主线程（main thread）。		
线程和进程都有自己的逻辑控制流，也可以并行（甚至并行的概念都类似），也可以进行上下文切换；区别在于，线程会共享代码和数据，在切换上下文这方面，线程要比进程快很多（因为线程小）。

## 小结
总的来说，这三种并行方法各有优劣。

* 基于进程
  * 不同进程之间不共享数据
  * 添加/移除/切换起来开销比较大 
* 基于I/O多路复用
  *  给了程序员更多权限
  *  共享数据
  *  编码更大复杂
  *  无法充分利用多核CPU
* 基于线程
  * 可以共享资源，但是更加容易出问题
  * 添加/移除/切换起来开销比较小（相对进程）
  * 难以调试
  

## 多线程的共享变量
一组并发线程运行在一个进程的上下文中。每个线程都有它自己的独立的线程上下文（thread context），包括线程ID、栈、指针、栈指针、程序计数器、通用目的寄存器和条件码；每个线程和其他线程共享进程上下文中的剩余部分，包括整个用户的虚拟地址空间。		
从实际的角度来说，一个线程去读写另外一个线程的寄存器值是不可能的。另外，任何线程都可以访问虚拟内存的任何位置。所以，我们要明白一个事实，寄存器并不共享，但是虚拟内存总是共享的，这也是无数多线程bug的根源。		
此外还有一个问题，每个独立的线程的线程栈的内存模型并不整齐清楚，它们被保存在虚拟地址空间的栈区域中，一般来说是被对应的线程独立的访问。注意！这里说的是一般，因为不同的线程栈是不对其他线程设防的，其他线程如果能获取到其他线程栈的指针，也是可以进行读写。
比如下面代码		

```C
#include <stdio.h>
#include <pthread.h>

#define N 2
void *thread(void *vargp);

char **ptr; // 全局变量

int main(int argc, char **argv) {
    int i ;
    pthread_t tid;
    char *msgs[N] = {
        "Hello from foo",
        "Hello from bar"
    };
    ptr =  msgs;
    for (i = 0; i < 2; i++) {
        Pthread_create(&tid, NULL, thread, (void *)i);
        Pthread_exit(NULL);
    }

}

void *thread(void *vargp) {
    int myid = (int)vargp;
    static int cnt = 0;
    
    // 这里每个线程都可以访问 ptr 这个全局变量
    printf("[%d]: %s (cnt=%d)\n", myid, ptr[myid], ++cnt);
    return NULL;
}

```

在C程序中的变量会根据存储类型被映射到虚拟内存：
> * 全局变量        
    全局变量指的是定义在函数之外的变量。
    在运行的时候，虚拟内存的读写区域只包含每个全局变量的唯一个实例，任何线程都可以引用。
> * 局部自动变量
    定义在函数内部但是没有static属性的变量。
    在运行的时候，每个线程的栈都包含它自己的所有局部变量
> * 局部静态变量
    在函数内用 static 关键字声明的变量。
    虚拟内存中有全局唯一的一份实例。

而我们说一个变量是共享变量的时候，当且仅当它的一个实例被一个以上的线程引用。

## 信号量
共享变量是方便的，但是也引入了同步错误。
严格来说，你没法确认操作系统将你的线程选择了一个正确的顺序。
如果在多线程中使用下列代码

```C++
int count = 0;
for(int i = 0;i < 500;i++) {
    count++;
}
```
这里并不代表count最后的值是500，因为多个线程有可能会在添加的时候重复。造成count总是小于500。
Edsger Dijkstra提出了信号量的方法，信号量s是具有非负整数值的全局变量，只能有两种特殊的操作来处理，分别是P和V。它们是如此运作的：


> * 运行 P，信号量 S 的值将被减少。企图进入临界区块的进程，需要先运行 P。当信号量 S 减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。
> * 运行 V，信号量 S 的值会被增加。结束离开临界区块的进程，将会运行 V。当信号量 S 不为负值时，先前被挡住的其他进程，将可获准进入临界区块。
P和V保证了一个正在运行的程序绝不可能进入这样一个状态--一个正确初始化的信号量有一个复制。这个被称为信号量的不变性。

### 读写问题
读写问题就互斥问题的一个概括。		
有的线程只读取对象，有的线程修改对象，修改对象的线程对于对象的访问是互斥的，多个读取线程可以同时读取对象。		
它有两个变种：
> 1. 读者优先
    如果写者没有获取到使用对象的权限，不应该让读者等待；
    在等待的写者之后到来的读者应该在写者之前处理；
    也就是说，只有没有读者的情况下，写者才能工作；
> 2. 写者优先
    一旦写者可以处理的时候，就不应该进行等待；
    在等待的写者之后到来的读者应该在写者之后处理；
    
## 其他线程问题
### 线程安全
这里的线程安全是一个比较笼统的定义。	

* 一个函数被称为线程安全（thread-safe）的，当且仅当被多个并发线程反复的调用时，它会一直产生正确的结果。
* 当一个线程不是线程安全的，那它就是线程不安全的（thread-unsafe）。

有四种线程不安全函数：
> 1. 不保护共享变量的函数。  		
    解决办法：使用同步操作来保护共享变量
    优点：调用程序中不需要做任何修改。
    缺点：同步操作会减慢程序的执行时间。    
> 2. 保持跨域多个调用的状态的函数。		
    解决办法：把状态当做参数
    缺点：容易出错
> 3. 返回只想静态变量的指针的函数。		
    解决办法1：重写函数，传递存放结果的变量的地址。
    解决办法2：在每个调用位置使用互斥锁加锁，调用函数，然后将函数结果复制到一个私有的内存位置，然后互斥锁解锁。
> 4. 调用线程不安全函数的函数。		
	解决办法：只调用线程安全的函数

### 可重入性
定义：当函数被多个线程调用时，不会引用任何共享数据。	
可重入函数通常要比不可重入的线程安全的函数高效一些，因为它们不需要同步操作。	
如果所有函数的参数都是传值传递的（即没有指针），那么函数就是**显式可重入的**，也就是说，不论怎么被调用，都可以断言它是可重入的。	
如果显式可重入函数中一些参数是引用传递的（即允许它们传递指针），那么我们就得到一个**隐式可重入的**函数，也就是说，如果我们调用线程小心地传递指向非共享数据的指针，那么它是可重入的。	

### 竞争
当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时，就会发生竞争。

### 死锁
死锁：如果一组线程被阻塞了，等待一个永远也不会为真的条件。	
死锁的四个条件：互斥、持有并等待、非抢占、循环等待。	
死锁是一个相当困难的问题，因为它不总是可预测的。


## 小结
一个并发程序是由在时间上重叠的一组逻辑流组成的。我们学习了三种不同的构建并发的机制：进程、I/O多路复用和线程。	           
进程是由内核自动调度的，而且因为它们有各自独立的虚拟地址空间，所以要实现共享数据，必须要有显式的进程间通信（IPC）机制。事件驱动程序创建它们自己的并发逻辑流，这些逻辑流被模型化为状态机，用I/O多路复用来显式的调度这些流。因为程序运行在一个单一进程中，所以在流之间共享数据速度很快且很容易。线程是这些方法的混合。同基于进程的流一样，线程也是有内核自动调度的。同基于I/O多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便地共享数据。	      
无论哪种并发机制，同步对共享数据的并发访问都是一个困难的问题。提出对信号量的P和V操作就是为了帮组解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如**生产者-消费者程序**中优先缓冲区和**读者-写者系统**中的共享对象这样的资源访问进行调度。一个并发预线程化的echo服务器提供了信号量使用场景的很好的例子。            	
并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。我们定义了四种线程不安全的函数，以及一些将他们变为线程安全的建议。可重入函数是线程安全函数的一个真子集，它不访问任何共享数据。可重入函数通常比不可重入函数更为有效，因为它们不惜要任何同步原语。竞争和死锁是并发程序中出线的另一些困难的问题。当程序员错误地假设逻辑流该如何调度是，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。