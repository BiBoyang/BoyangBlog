# 伯阳的网络笔记（六）：TLS
> 因为疫情期间在外当志愿者，晚上回家无聊翻翻网络知识，权当记录了。
> 初始动笔：2019-02-28
> 修改时间：2019-04-06



# 前言
人们最初设计互联网的时候，很少考虑到安全。这样造成一个问题：**核心通信协议本质上是不安全的**，只能依靠所有参与方的诚信。这显然有些理想主义了。

之后，随着安全需求的增加，我们提出了安全通信的共识，一般来说，具有下列特性：
* 机密性    
        仅有发送方和接收方能够理解传输数据的内容。
* 信息完整性    
        传输双方自然是想通信的内容是完整的。
* 身份鉴别    
        确实双方是正确的。


基本上所有的安全措施，都是为了维护以上几点而设计的。

TCP 和 IP 是互联网的建立基础，它们本身就是非常容易受到攻击的；当然，不止它们，其他协议，比如 DNS 和 BGP 也是同样容易受到攻击。


# 加密算法
为了更加浅显易懂，我们虚构三个人物，通信双方 Alice 和 Bob，以及一个想要窃听的坏人 Eve。
## 对称加密
**对称加密**，又称之为私钥加密，是一种混淆算法。加密和解密使用相同的密钥。

Alice 使用密钥给信息进行了加密，然后 Bob 在接收到信息的时候使用相同的密钥进行解密，Eve 虽然可以截获信息，但是没有密钥，无法解读。

![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_26.png?raw=true)

比较典型的对称加密算法有 DES 和 AES 算法。

* 优点：计算量小、加密速度快、加密效率高。

* 缺点：交易双方都使用同样密钥，安全性得不到保证；每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。

## 非对称加密
**非对称加密**，又称双钥加密，加密和解密使用公钥和私钥。用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

Alice 将公钥发给 Bob，然后 Bob 用公钥将信息加密发给 Alice；Alice 在收到信息后，使用私钥进行解密。

![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_27.png?raw=true)

最有名的非对称加密算法就是 [RSA 算法](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).

# 数字签名
数字签名相当于现实世界中的盖章、签名的功能在计算机世界中进行实现的技术。数字签名可以识别篡改、伪装、防止抵赖。

在数字签名中，有 2 种行为：
* 生成消息签名的行为
* 验证消息签名的行为

生成消息签名的人是由消息发送者完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值。

验证数字签名的人是第三方。第三方验证消息的来源是否属于发送者。验证结果可以是成功，也可以是失败。

数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。签名密钥只能由签名人持有，而验证密钥则是任何需要验证签名的人都可以持有。


# TLS

TLS 是一个密码学协议，用于保证通信双方之间的会话安全。TLS是一个非常复杂且博大的协议，对于一般开发者来说只需要理解其工作原理即可，如果对它非常感兴趣，可以查阅[RFC5246](https://tools.ietf.org/html/rfc5246)。

它的头部如图所示。
![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_28.png?raw=true)


# TLS 握手

TLS 的握手是整个协议中最精密复杂的部分，在这个过程中，通信双方协商连接参数，并且完成身份验证。

由于使用的功能的不同，一般分为三种握手：
1. 完整的握手，对服务器进行身份验证；
2. 恢复之前的会话采用的简短握手；
3. 对客户端和服务器都进行身份验证的握手。

### 完整的握手
主要分为以下四个步骤（TLS/1.2）：
1. 交换各自支持的功能，对需要的连接参数达成一致；
2. 验证出示的证书，或使用其他方式进行身份验证；
3. 对将用于保护会话的共享主密钥达成一致；
4. 验证握手消息并未被第三方团体修改。

![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_29.png?raw=true)

##### 第一次握手
客户端向服务端发送 Client Hello 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；

##### 第二次握手
服务端收到客户端支持的协议版本、加密算法等信息后；
1. 向客户端发送 Server Hello 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；
2. 向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；
3. 向客户端发送 Server Key Exchange 消息，传递公钥以及签名等信息；
4. 向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；
5. （可选）向客户端发送可选的消息 CertificateRequest，验证客户端的证书；

##### 第三次握手
客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；
1. 向服务端发送 Client Key Exchange 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（Pre Master Secret）；
2. 向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输；
3. 向服务端发送 Finished 消息，其中包含加密后的握手信息；

##### 第四次握手
服务端收到 Change Cipher Spec 和 Finished 消息后；
1. 向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；
2. 向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；


## TLS/1.2 的缺点
我们可以发现，TLS 的握手是四次握手，需要耗费 2 RTT，这是一个很大的消耗了，要知道 TCP 也才耗费 1.5 RTT，所以，之后版本的 TLS 把提升性能放到了重点。

## TLS 1.3
为了提升 TLS 的性能和安全性，TLS 1.3 登场。它主要是有以下几个方向的提升：
1. 相比于 TLS 1.2 的 2 RTT，TLS 可以做到 1 RTT，甚至 0 RTT；
2. 引入了新的密钥协商机制 — PSK；
3. ServerHello 之后的所有握手消息采取了加密操作，可见明文大大减少；
4. DSA 证书不再允许在 TLS 1.3 中使用。

而为了做这些提升，TLS 1.3 几乎和 TLS 1.2 完全不一样了，不像 HTTP/1.x 和 HTTP/2 互相兼容。握手过程如下图所示：

![](![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_30.png?raw=true))

##### 第一次握手
客户端发送ClientHello消息，该消息主要包括客户端支持的协议版本、DH密钥交换参数列表KeyShare；
##### 第二次握手
服务端回复ServerHello，包含选定的加密套件；发送证书给客户端；使用证书对应的私钥对握手消息签名，将结果发送给客户端；选用客户端提供的参数生成ECDH临时公钥，结合选定的DH参数计算出用于加密HTTP消息的共享密钥；服务端生成的临时公钥通过KeyShare消息发送给客户端；
##### 第三次握手
客户端接收到KeyShare消息后，使用证书公钥进行签名验证，获取服务器端的ECDH临时公钥，生成会话所需要的共享密钥；
双方使用生成的共享密钥对消息加密传输，保证消息安全。

我们可以发现，虽然看起来是有第三次握手，但是第三次实际上是带着数据一起传送过去，也就是相当于两次握手了。

> 不过很有意思的是，TCP 三次握手的第三次握手也是可以带数据的，那为什么 TCP 不称之为两次握手呢？ 




# 资料来源

《HTTPS权威指南》

[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

[为什么 HTTPS 需要 7 次握手以及 9 倍时延](https://draveness.me/whys-the-design-https-latency/)