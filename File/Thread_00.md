# Threading Programming Guide(一)：线程和线程管理
[Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1)学习记录。
其余部分：
* [Threading Programming Guide(二)：RunLoop](xx)
* [Threading Programming Guide(三)：同步](xx)
* [Threading Programming Guide(四)：线程安全和有关词汇](xx)

## 介绍
线程是使在单个应用程序中同时执行多个代码路径成为可能的几种技术之一。尽管诸如操作对象和Grand Central Dispatch（GCD）之类的较新技术为实现并发提供了更现代，更高效的基础架构，但是OS X和iOS还提供了用于创建和管理线程的接口。

本文档介绍了OS X中可用的线程包，并向您展示了如何使用它们。本文档还描述了为支持应用程序内的线程化和多线程代码同步而提供的相关技术。

## 关于线程编程
多年来，最大的计算机性能在很大程度上受到位于计算机核心的单个微处理器速度的限制。但是，随着单个处理器的速度开始达到其实际极限，芯片制造商转向了多核设计，从而使计算机有机会同时执行多项任务。尽管OS X只要能够执行与系统相关的任务就可以利用这些内核，但是您自己的应用程序也可以通过线程利用它们。

### 什么是线程
线程是在应用程序内部实现多个执行路径的相对轻量的方法。在系统级别，程序并排运行，系统根据每个程序的需求和其他程序的需求分配执行时间。但是，每个程序中都存在一个或多个执行线程，这些线程可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理着这些执行线程，调度它们在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。

从技术角度来看，线程是管理代码执行所需的内核级和应用程序级数据结构的组合。内核级结构在一个可用内核上协调事件向线程的调度和线程的抢占式调度。应用程序级别的结构包括用于存储函数调用的调用堆栈，以及应用程序管理和操纵线程的属性和状态所需的结构。

在非并行应用程序中，只有一个执行线程。该线程以应用程序的main例程开始和结束，并且一个一个地分支到不同的方法或函数，以实现应用程序的整体行为。相反，支持并发的应用程序从一个线程开始，并根据需要添加更多线程以创建其他执行路径。每个新路径都有其自己的自定义启动例程，该例程独立于应用程序main例程中的代码运行。应用程序中具有多个线程可提供两个非常重要的潜在优势：
* 多个线程可以提高应用程序的感知响应能力。
* 多线程可以提高应用程序在多核系统上的实时性能。

如果您的应用程序只有一个线程，则该线程必须执行所有操作。它必须响应事件，更新应用程序的窗口并执行实现应用程序行为所需的所有计算。仅具有一个线程的问题在于，它一次只能做一件事。那么，当您的计算之一需要很长时间才能完成时，会发生什么呢？当您的代码忙于计算所需的值时，您的应用程序将停止响应用户事件并更新其窗口。如果此行为持续足够长的时间，则用户可能会认为您的应用程序已挂起，并试图强行退出它。但是，如果将自定义计算移动到单独的线程上，则应用程序的主线程将可以自由地更及时地响应用户交互。

对于当今常见的多核计算机，线程提供了一种提高某些类型的应用程序性能的方法。执行不同任务的线程可以在不同处理器核心上同时执行操作，从而使应用程序可以在给定的时间内增加其工作量。

当然，线程不是解决应用程序性能问题的灵丹妙药。除了线程提供的好处外，还有潜在的问题。在应用程序中具有多个执行路径会给您的代码增加相当多的复杂性。每个线程必须与其他线程协调其操作，以防止其破坏应用程序的状态信息。因为单个应用程序中的线程共享相同的内存空间，所以它们可以访问所有相同的数据结构。如果两个线程试图同时操作相同的数据结构，则一个线程可能会以破坏结果数据结构的方式覆盖另一个线程的更改。即使有适当的保护措施，您仍然必须提防编译器优化，这些优化会在代码中引入细微（而不是细微）的错误。

### 线程术语
在深入讨论线程及其支持技术之前，有必要定义一些基本术语。
如果您熟悉UNIX系统，则可能会发现本文档对术语“任务（task）”的使用有所不同。在UNIX系统上，术语“任务（task）”有时用于表示正在运行的进程。
本文档采用以下术语：

* 术语 **线程(thread)** 用于指代代码的独立执行路径。
* 术语 **进程(process)** 用于指代一个正在运行的可执行文件，它可以包含多个线程。
* 术语 **任务(task)** 用于指代需要执行的工作的抽象概念。

### 线程替代技术
自己创建线程的一个问题是它们增加了代码的不确定性。线程是在应用程序中支持并发的相对较低级别和复杂方式。如果您不完全了解设计选择的含义，则很容易会遇到同步或时序问题，其严重性可能从微妙的行为更改到应用程序崩溃和用户数据损坏。

要考虑的另一个因素是您是否根本需要线程或并发。线程解决了如何在同一进程内同时执行多个代码路径的特定问题。但是，在某些情况下，您所做的工作量不能保证并发。线程在内存消耗和CPU时间方面都会给您的进程带来大量开销。您可能会发现此开销对于预期的任务而言太大，或者其他选项更易于实现。

下表列出了一些线程替代方案。该表既包括线程的替代技术（如操作对象和GCD），还包括旨在有效利用现有线程的替代方法。


|  技术 |  描述 |
|---|---|
| Operation objects  | 在辅助线程上执行的任务的封装。该封装隐藏了执行任务的线程管理方面，使您可以自由地专注于任务本身。通常将这些对象与操作队列对象结合使用，该操作队列对象实际上管理一个或多个线程上操作对象的执行。  |
| Grand Central Dispatch (GCD) | 使用GCD，您可以定义要执行的任务并将其添加到工作队列中，该工作队列可以在适当的线程上处理任务的调度。工作队列考虑了可用核心的数量和当前负载，以使您比使用线程可以更有效地执行任务。  |
| Idle-time notifications | 对于相对较短且优先级非常低的任务，空闲时间通知使您可以在应用程序不那么忙时执行任务。Cocoa支持使用该NSNotificationQueue对象的空闲时间通知。要请求空闲时间通知，请NSNotificationQueue使用NSPostWhenIdle选项将通知发布到默认对象。队列会延迟通知对象的传递，直到运行循环变得空闲为止。  |
| Asynchronous functions | 系统界面包括许多异步功能，这些功能可以为您提供自动并发。这些API可以使用系统守护程序和进程，或者创建自定义线程来执行其任务并将结果返回给您。（实际的实现是无关紧要的，因为它与代码分开了。）在设计应用程序时，请寻找具有异步行为的函数，并考虑使用它们，而不是在自定义线程上使用等效的同步函数。  |
| Timers  |  您可以在应用程序的主线程上使用计时器来执行周期性的任务，这些任务太琐碎而无法使用线程，但仍需要定期进行服务。 |
| Separate processes  | 尽管比线程更重，但是在任务仅与应用程序有切线关系的情况下，创建单独的进程可能会很有用。如果任务需要大量内存或必须使用root特权执行，则可以使用进程。  |

### 线程支持
如果您已有使用线程的代码，则OS X和iOS提供了几种在应用程序中创建线程的技术。此外，两个系统还提供了对管理和同步在这些线程上需要完成的工作的支持。以下各节描述了在OS X和iOS中使用线程时需要了解的一些关键技术。

#### 线程包
 尽管线程的基本实现机制是Mach线程，但是您很少（如果有的话）使用Mach级别的线程。相反，通常使用更方便的POSIX API或其派生之一。Mach实现确实提供了所有线程的基本功能，但是包括抢占执行模型和调度线程的能力，因此它们彼此独立。


|  技术 | 描述  |
|---|---|
|  Cocoa 线程 |  Cocoa使用NSThread该类实现线程。Cocoa还提供了NSObject用于生成新线程并在已经运行的线程上执行代码的方法。有关更多信息，请参见下文|
| POSIX线程  |  POSIX线程提供用于创建线程的基于C的接口。如果您不是在编写Cocoa应用程序，那么这是创建线程的最佳选择。POSIX接口使用起来相对简单，并且为配置线程提供了足够的灵活性。有关更多信息，请参见下文 |
|  多处理服务 | iOS弃用  |

 在应用程序级别，所有线程的行为基本上与其他平台上的行为相同。启动线程后，线程以三种主要状态之一运行：运行(running），准备（ready）或阻塞（blocked）。如果线程当前未在运行，则要么阻塞并等待输入，要么准备运行，但尚未安排这样做。线程继续在这些状态之间来回移动，直到最终退出并进入终止状态。

创建新线程时，必须为该线程指定一个入口点函数（对于Cocoa线程，则为入口点方法）。该入口点函数构成您要在线程上运行的代码。当函数返回时，或显式终止线程时，该线程将永久停止并被系统回收。因为就内存和时间而言，创建线程的成本相对较高，所以建议您的入口点函数进行大量工作或设置运行循环以允许重复执行工作。

有关可用的线程技术以及如何使用它们的更多信息，请参阅下文。

#### RunLoop
运行循环是用于管理异步异步到达线程的事件的基础架构。运行循环通过监视线程的一个或多个事件源来工作。当事件到达时，系统将唤醒线程并将事件分配给运行循环，然后运行循环将其分配给您指定的处理程序。如果不存在任何事件并准备处理事件，则运行循环会将线程置于睡眠状态。

您不需要对创建的任何线程使用运行循环，但是这样做可以为用户提供更好的体验。运行循环可以创建使用最少资源的长寿命线程。由于运行循环在无事可做时将其线程置于睡眠状态，因此消除了轮询的需要，这浪费了CPU周期，并阻止了处理器本身休眠并节省功耗。

要配置运行循环，您所需要做的就是启动线程，获取对运行循环对象的引用，安装事件处理程序，并告诉运行循环运行。OS X提供的基础结构会自动为您处理主线程运行循环的配置。但是，如果计划创建寿命长的辅助线程，则必须自己为这些线程配置运行循环。

#### 同步工具
线程编程的危害之一是多个线程之间的资源争用。如果多个线程尝试同时使用或修改同一资源，则可能会出现问题。缓解此问题的一种方法是完全消除共享资源，并确保每个线程都有其自己独特的资源集进行操作。但是，当不能完全维护单独的资源时，您可能必须使用锁，条件，原子操作和其他技术来同步对资源的访问。

锁为一次只能由一个线程执行的代码提供了暴力保护形式。锁的最常见类型是互斥锁，也称为互斥锁。当一个线程试图获取另一个线程当前持有的互斥锁时，它将阻塞，直到另一个线程释放该锁为止。多个系统框架均支持互斥锁，尽管它们都基于相同的基础技术。此外，可可提供互斥锁的多种变体，以支持不同类型的行为，例如递归。有关可用锁类型的更多信息，请参见锁。

除锁定外，系统还提供条件支持，以确保在应用程序中正确执行任务顺序。条件充当关守，阻塞给定线程，直到它表示的条件变为真为止。发生这种情况时，条件将释放线程并允许其继续。POSIX层和Foundation框架都直接提供条件支持。（如果使用操作对象，则可以在操作对象之间配置依赖关系以对任务的执行进行排序，这与条件提供的行为非常相似。）

尽管锁和条件在并发设计中非常常见，但是原子操作是保护和同步对数据的访问的另一种方法。在可以对标量数据类型执行数学或逻辑运算的情况下，原子运算提供了一种轻巧的替代锁的方法。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

#### 线程间通信
尽管良好的设计可以最大程度地减少所需的通信量，但在某些时候，线程之间的通信还是很有必要的。（线程的工作是为您的应用程序工作，但是如果从未使用该工作的结果，那有什么用呢？）线程可能需要处理新的工作请求或将其进度报告给应用程序的主线程。在这些情况下，您需要一种从一个线程到另一个线程获取信息的方法。幸运的是，线程共享相同的进程空间这一事实意味着您有很多通信选项。    
线程之间有许多通信方式，每种都有其自身的优点和缺点。配置线程本地存储列出了可以在OS X中使用的最常见的通信机制。（除了消息队列和Cocoa分布式对象，这些技术在iOS中也可用。）按递增顺序列出了下表中的技术复杂。


|  机制 | 描述  |
|---|---|
| 直接通信  |  	Cocoa应用程序支持直接在其他线程上执行选择器的功能。这种功能意味着一个线程可以在任何其他线程上执行一种方法。因为它们是在目标线程的上下文中执行的，所以以此方式发送的消息将在该线程上自动序列化。 |
|  全局变量，共用内存和对象 |  在两个线程之间传递信息的另一种简单方法是使用全局变量，共享对象或共享内存块。尽管共享变量既快速又简单，但是它们比直接消息传递更脆弱。必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性。否则可能会导致竞争状况，数据损坏或崩溃。 |
|  条件 |  条件是一种同步工具，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时才运行。 |
| RunLoop Sources  |  自定义运行循环源是您设置为在线程上接收特定于应用程序的消息的源。由于它们是事件驱动的，因此运行循环源可以在无事可做时使线程自动进入睡眠状态，从而提高了线程的效率。 |
| 端口和套接字  |  基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用运行循环源实现端口，因此，当端口上没有数据等待时，线程将进入睡眠状态。 |
|  消息队列 |传统的多处理服务定义了先进先出（FIFO）队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如某些其他通信技术有效。 |
|  Cocoa分布式对象 |  分布式对象是一种Cocoa技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，在这些进程之间进行事务的开销已经很高。 |


### 设计技巧
以下各节提供准则，以帮助您以确保代码正确性的方式帮助您实现线程。其中一些准则还提供了一些技巧，以帮助您使用自己的线程代码获得更好的性能。与任何性能提示一样，在更改代码之前，之中和之后，您应始终收集相关的性能统计信息。

#### 避免直接创建线程
手动编写线程创建代码很繁琐，并且可能容易出错，因此应尽可能避免这样做。OS X和iOS通过其他API为并发提供隐式支持。与其自己创建一个线程，不如考虑使用异步API，GCD或NSOperation来完成工作。这些技术可以在后台为您完成与线程相关的工作，并且可以保证正确执行。此外，GCD和操作对象等技术旨在根据当前系统负载调整活动线程的数量，从而比您自己的代码更有效地管理线程。

#### 保持线程合理忙碌
如果决定手动创建和管理线程，请记住线程会消耗宝贵的系统资源。您应该尽力确保分配给线程的所有任务都可以长期有效地工作。同时，您不必担心终止花费大部分时间空闲的线程。线程占用的内存非常少，其中一些已连接，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多的物理内存供其他系统进程使用。

> 重点：开始终止空闲线程之前，应始终记录一组应用程序当前性能的基准度量。尝试更改后，请进行其他度量以验证更改实际上是在提高性能，而不是损害性能。

#### 避免共用数据结构
避免与线程相关的资源冲突的最简单，最简单的方法是为程序中的每个线程提供所需数据的自己的副本。当您最小化线程之间的通信和资源争用时，并行代码最有效。

创建多线程应用程序很困难。即使您非常小心并在代码的所有适当位置锁定共享数据结构，您的代码在语义上仍可能是不安全的。例如，如果您的代码希望共享数据结构按特定顺序进行修改，则可能会遇到问题。将您的代码更改为基于事务的模型以进行补偿可能会随后抵消具有多个线程的性能优势。首先消除资源争用通常会导致设计简单，性能出色。

#### 线程与用户界面
如果您的应用程序具有图形用户界面，则建议您接收与用户相关的事件，并从应用程序的主线程启动界面更新。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。某些框架（例如Cocoa）通常需要此行为，但是即使对于那些不需要的框架，在主线程上保留此行为也具有简化管理用户界面的逻辑的优势。

有一些值得注意的例外，从其他线程执行图形操作是有利的。例如，您可以使用辅助线程来创建和处理图像以及执行其他与图像有关的计算。对这些操作使用辅助线程可以大大提高性能。但是，如果不确定某个特定的图形操作，请计划从主线程执行该操作。

#### 注意退出时的线程行为

进程一直运行到所有非分离线程都退出为止。默认情况下，仅将应用程序的主线程创建为非分离主线程，但是您也可以以这种方式创建其他线程。当用户退出应用程序时，通常认为立即终止所有分离的线程是适当的行为，因为分离的线程完成的工作被认为是可选的。但是，如果您的应用程序正在使用后台线程将数据保存到磁盘或执行其他关键工作，则可能需要将这些线程创建为非分离线程，以防止在应用程序退出时丢失数据。

将线程创建为非分离线程（也称为可连接线程）需要您进行额外的工作。因为大多数高级线程技术默认情况下都不创建可连接线程，所以您可能必须使用POSIX API创建线程。此外，您必须将代码添加到应用程序的主线程中，以便在非分离线程最终退出时加入它们。

#### 处理异常
引发异常时，异常处理机制依赖于当前的调用堆栈来执行任何必要的清除。由于每个线程都有自己的调用堆栈，因此每个线程负责捕获自己的异常。在辅助线程中未能捕获到异常与在主线程中未能捕获到异常相同：拥有过程终止。您不能将未捕获的异常抛出到另一个线程进行处理。

如果需要在当前线程中将异常情况通知另一个线程（例如主线程），则应捕获该异常，并仅向该另一个线程发送一条消息，指出发生了什么情况。根据您的模型和您要执行的操作，捕获到异常的线程可以继续处理（如果可能的话），等待指令或直接退出。

> 注意：在Cocoa中，NSException对象是一个自包含的对象，一旦被捕获，即可在线程之间传递。

在某些情况下，可能会自动为您创建一个异常处理程序。例如，`@synchronized`在Objective-C中的指令包含一个隐式异常处理程序。

#### 干净地终止线程
退出线程的最佳方法自然是让线程到达其主入口点例程的末尾。尽管有立即终止线程的功能，但这些功能仅应作为最后的手段使用。在线程到达其自然终点之前终止该线程可防止线程在其自身清除之后清理。如果线程已分配内存，打开文件或获取其他类型的资源，则您的代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。

#### 库中的线程安全
尽管应用程序开发人员可以控制应用程序是否使用多个线程执行，但是库开发人员却不能。开发库时，必须假定调用应用程序是多线程的，或者可以随时切换为多线程。因此，您应该始终对代码的关键部分使用锁。

对于库开发人员，仅当应用程序成为多线程时才创建锁是不明智的。如果您需要在某个时候锁定代码，请在使用库的早期创建锁定对象，最好是通过某种显式调用来初始化库。尽管您也可以使用静态库初始化函数来创建此类锁，但仅在没有其他方法时才尝试这样做。执行初始化函数会增加加载库所需的时间，并且可能会对性能产生不利影响。

注意：请始终记住平衡调用以锁定和解锁库中的互斥锁。您还应该记住锁定库数据结构，而不是依靠调用代码来提供线程安全的环境。

如果您正在开发Cocoa库，则可以注册为``NSWillBecomeMultiThreadedNotification``的观察者，以在应用程序成为多线程时收到通知。但是，您不应依赖于接收此通知，因为它可能在调用库代码之前就已分派。

## 线程管理
OS X或iOS中的每个进程（应用程序）都由一个或多个线程组成，每个线程代表通过应用程序代码执行的单个路径。每个应用程序都从一个线程开始，该线程运行该应用程序的main功能。应用程序可以产生其他线程，每个线程都执行特定功能的代码。

当应用程序产生新线程时，该线程将成为应用程序进程空间内的一个独立实体。每个线程都有其自己的执行堆栈，并由内核分别计划在运行时运行。线程可以与其他线程和其他进程通信，执行I / O操作以及执行您可能需要执行的其他任何操作。但是，由于它们在同一进程空间内，因此单个应用程序中的所有线程共享同一虚拟内存空间，并且与进程本身具有相同的访问权限。

### 线程成本
就内存使用和性能而言，线程化会给您的程序（和系统）带来实际成本。每个线程都需要在内核内存空间和程序的内存空间中分配内存。使用有线内存将管理线程和协调其调度所需的核心结构存储在内核中。线程的堆栈空间和每个线程的数据存储在程序的内存空间中。这些结构中的大多数是在您首次创建线程时创建和初始化的，由于与内核之间的交互作用，该过程可能相对昂贵。

下表量化了与在应用程序中创建新的用户级线程相关的近似成本。其中一些成本是可配置的，例如分配给辅助线程的堆栈空间量。创建线程的时间成本是一个近似值，应仅用于彼此之间的相对比较。线程创建时间会因处理器负载，计算机速度以及可用系统和程序内存的数量而有很大不同。

| 成本项  |  大致成本 | 注释 |
|-----|-----|-----|
|  内核数据结构  | 大约1KB<br>  | 该内存用于存储线程数据结构和属性，其中许多数据结构和属性分配为有线内存，因此无法分页到磁盘。  |
|  栈空间 | 512KB(辅助线程)<br>8MB(OSX主线程)<br>1MB(iOS主线程)  |辅助线程允许的最小堆栈大小为16 KB，并且堆栈大小必须为4 KB的倍数。在线程创建时会在进程空间中预留此内存的空间，但是直到需要它们时，才会创建与该内存关联的实际页面。|
| 创建时间  | 约90微秒  |  该值反映了从创建线程的初始调用到线程的入口点例程开始执行之间的时间。这些数字是通过分析在基于Intel的iMac（具有2 GHz Core Duo处理器和1 GB运行OS X v10.5的RAM）上的线程创建过程中生成的平均值和中值确定的。 |

> 注意：  由于具有底层内核支持，因此操作对象通常可以更快地创建线程。他们不是每次都从头开始创建线程，而是使用内核中已经存在的线程池来节省分配时间。

编写线程代码时要考虑的另一个成本是生产成本。设计线程化的应用程序有时可能需要对组织应用程序的数据结构的方式进行根本性的更改。为避免使用同步，可能需要进行这些更改，否则同步本身可能对设计不良的应用程序造成巨大的性能损失。设计这些数据结构以及调试线程代码中的问题可能会增加开发线程应用程序所需的时间。但是，如果线程花费太多时间等待锁或不执行任何操作，则避免这些开销会在运行时产生更大的问题。

### 创建线程
创建低级线程相对简单。在所有情况下，您都必须具有充当线程的主要入口点的函数或方法，并且必须使用可用的线程例程之一来启动线程。以下各节显示了更常用的线程技术的基本创建过程。使用这些技术创建的线程将继承一组默认属性，这些属性由您使用的技术确定。

#### 使用NSThread
有两种使用NSThread该类创建线程的方法：

* 使用`detachNewThreadSelector:toTarget:withObject:class`方法产生新线程。
* 创建一个新`NSThread`对象并调用其`start`方法。（仅在iOS和OS X v10.5及更高版本中受支持。）

两种技术都会在您的应用程序中创建一个分离线程。分离的线程意味着线程退出时系统会自动回收线程的资源。这也意味着您的代码以后不必与线程显式连接。

由于该`detachNewThreadSelector:toTarget:withObject:`方法在OS X的所有版本中均受支持，因此经常在使用线程的现有Cocoa应用程序中找到。要分离新线程，只需提供要用作线程入口点的方法名称（指定为选择器），定义该方法的对象以及要在启动时传递给线程的任何数据。 。以下示例显示了此方法的基本调用，该调用使用当前对象的自定义方法生成一个线程。

```
[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];
```
在OS X v10.5之前，您NSThread主要使用该类生成线程。尽管您可以获取一个NSThread对象并访问一些线程属性，但是只能在线程运行之后从线程本身进行操作。在OS X v10.5中，添加了对创建NSThread对象的支持，而无需立即产生相应的新线程。（此支持在iOS中也可用。）此支持使得可以在启动线程之前获取和设置各种线程属性。这也使得以后可以使用该线程对象来引用正在运行的线程。

NSThread在OS X v10.5及更高版本中初始化对象的简单方法是使用该`initWithTarget:selector:object:`方法。此方法`detachNewThreadSelector:toTarget:withObject:`使用与该方法完全相同的信息，并使用它来初始化新NSThread实例。但是，它不会启动线程。要启动线程，请`start`显式调用线程对象的方法，如以下示例所示：
```
NSThread* myThread = [[NSThread alloc] initWithTarget:self   
                                selector:@selector(myThreadMainMethod:)
                                        object:nil];
[myThread start];  // Actually create the thread
```
> 注意：使用该`initWithTarget:selector:object:`方法的另一种方法是继承NSThread并覆盖其main方法。您将使用此方法的重写版本来实现线程的主入口点。

如果您有一个NSThread对象的线程当前正在运行，则可以向该线程发送消息的`performSelector:onThread:withObject:waitUntilDone:`一种方法是使用应用程序中几乎所有对象的方法。OS X v10.5中引入了对在线程（主线程除外）上执行选择器的支持，这是在线程之间进行通信的便捷方式。（此支持在iOS中也可用。）使用此技术发送的消息由另一个线程直接执行，作为其正常运行循环处理的一部分。（当然，这确实意味着目标线程必须在其RunLoop中运行）以这种方式进行通信时，您可能仍需要某种形式的同步，但是比在线程之间设置通信端口更简单。
> 注意：  尽管对于线程间的偶尔通信有好处，但是您不应将 performSelector:onThread:withObject:waitUntilDone:方法用于时间紧迫或线程间的频繁通信。

#### 使用POSIX线程
OS X和iOS为使用POSIX线程API创建线程提供了基于C的支持。该技术实际上可以用在任何类型的应用程序（包括Cocoa和Cocoa Touch应用程序）中，如果您要为多个平台编写软件，则可能会更加方便。适当地调用了用于创建线程的POSIX例程pthread_create。

下面显示了两个使用POSIX调用创建线程的自定义函数。该LaunchThread函数创建一个新线程，其主例程在该PosixThreadMainRoutine函数中实现。由于POSIX默认将线程创建为可连接线程，因此本示例更改了线程的属性以创建分离的线程。将线程标记为已分离使系统有机会在退出时立即回收该线程的资源。

```C++
#include <assert.h>
#include <pthread.h>
 
void* PosixThreadMainRoutine(void* data)
{
    // Do some work here.
 
    return NULL;
}
 
void LaunchThread()
{
    // Create the thread using POSIX routines.
    pthread_attr_t  attr;
    pthread_t       posixThreadID;
    int             returnVal;
 
    returnVal = pthread_attr_init(&attr);
    assert(!returnVal);
    returnVal = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    assert(!returnVal);
 
    int     threadError = pthread_create(&posixThreadID, &attr, &PosixThreadMainRoutine, NULL);
 
    returnVal = pthread_attr_destroy(&attr);
    assert(!returnVal);
    if (threadError != 0)
    {
         // Report an error.
    }
}
```
如果将上述清单中的代码添加到一个源文件中并调用该LaunchThread函数，它将在您的应用程序中创建一个新的分离线程。当然，使用此代码创建的新线程将无用。线程将启动，几乎立即退出。为了使事情变得更有趣，您需要向该PosixThreadMainRoutine函数添加代码以完成一些实际工作。为了确保线程知道要执行的工作，可以在创建时将其传递给一些数据的指针。您将此指针作为pthread_create函数的最后一个参数传递。

要将信息从新创建的线程传递回应用程序的主线程，您需要在目标线程之间建立通信路径。对于基于C的应用程序，有多种方法可以在线程之间进行通信，包括使用端口，条件或共享内存。对于寿命长的线程，几乎应该始终设置某种线程间通信机制，以为应用程序的主线程提供一种检查线程状态或在应用程序退出时将其干净关闭的方法

#### 使用NSObject生成线程
在iOS和OS X v10.5及更高版本中，所有对象都可以生成新线程并使用它执行其方法之一。该``performSelectorInBackground:withObject:``方法创建一个新的分离线程，并使用指定的方法作为新线程的入口点。例如，如果您有某个对象（由表示myObj），并且该对象具有一个doSomething要在后台线程中运行的方法，则可以使用以下代码来执行该操作：
```
[myObj performSelectorInBackground：@selector（doSomething）withObject：nil];
```
调用此方法的效果是一样的，如果你调用``detachNewThreadSelector:toTarget:withObject:``的方法NSThread与当前对象，选择和参数对象作为参数。立即使用默认配置生成新线程并开始运行。在选择器内部，必须像配置任何线程一样配置线程。例如，如果您打算使用自动释放池（如果您不使用垃圾回收），则需要设置它，并配置线程的RunLoop。

#### 在Cocoa应用程序中使用POSIX线程
尽管NSThread该类是在Cocoa应用程序中创建线程的主要接口，但是您可以自由使用POSIX线程，如果这样做对您更方便。例如，如果您已经有使用POSIX线程的代码并且不想重写它，则可以使用。如果确实打算在Cocoa应用程序中使用POSIX线程，则仍应了解Cocoa和线程之间的交互作用，并遵守以下各节中的准则。

##### 保护Cocoa框架
对于多线程应用程序，Cocoa框架使用锁和其他形式的内部同步来确保它们的行为正确。但是，为了防止这些锁在单线程情况下降低性能，在应用程序使用NSThread类产生其第一个新线程之前，Cocoa不会创建它们。如果仅使用POSIX线程例程生成线程，则Cocoa不会收到需要知道您的应用程序现在是多线程的通知。发生这种情况时，涉及Cocoa框架的操作可能会使您的应用程序不稳定或崩溃。

为了让Cocoa知道您打算使用多个线程，您所要做的就是使用NSThread类产生一个线程，然后立即退出该线程。您的线程入口点无需执行任何操作。仅使用生成一个线程的行为NSThread就足以确保将Cocoa框架所需的锁放置到位。

如果不确定Cocoa是否认为您的应用程序是多线程的，则可以使用的isMultiThreaded方法NSThread进行检查。

##### 混合POSIX和Cocoa锁
在同一应用程序中混合使用POSIX和Cocoa锁是安全的。可可锁和条件对象实际上只是POSIX互斥对象和条件的包装。但是，对于给定的锁，必须始终使用相同的接口来创建和操作该锁。换句话说，您不能使用Cocoa NSLock对象来操纵使用该pthread_mutex_init函数创建的互斥对象，反之亦然。



### 配置线程属性
在创建线程之后，有时甚至在创建线程之前，您可能需要配置线程环境的不同部分。以下各节描述了可以进行的某些更改以及何时进行更改。

#### 配置线程的堆栈大小
对于您创建的每个新线程，系统都会在进程空间中分配特定数量的内存，以充当该线程的堆栈。堆栈管理堆栈帧，也是声明线程的任何局部变量的地方。     
如果要更改给定线程的堆栈大小，则必须在创建线程之前进行更改。尽管NSThread只有iOS和OS X v10.5及更高版本才提供使用设置堆栈大小的功能，但是所有线程技术都提供了一些设置堆栈大小的方法。


| 技术  | 选项   |
|---|---|
|Cocoa | 在iOS和OS X v10.5及更高版本中，分配和初始化NSThread对象（请勿使用``detachNewThreadSelector:toTarget:withObject:``方法）。在调用start线程对象的方法之前，请使用该``setStackSize:``方法指定新的堆栈大小。  |
| POSIX  |  创建一个新``pthread_attr_t``结构，并使用该``pthread_attr_setstacksize``函数更改默认堆栈大小。`pthread_create`创建线程时，将属性传递给函数。|
| Multiprocessing Services  |  MPCreateTask创建线程时，将适当的堆栈大小值传递给函数。 |

#### 配置线程本地存储(TLS)
每个线程维护一个键-值对的字典，可以从线程中的任何位置进行访问。您可以使用此词典存储要在整个线程执行过程中保留的信息。例如，您可以使用它存储要在线程运行循环的多次迭代中保留的状态信息。

Cocoa和POSIX以不同的方式存储线程字典，因此您不能混合和匹配对这两种技术的调用。但是，只要您在线程代码中坚持使用一种技术，最终结果应该是相似的。在Cocoa中，可以使用对象的threadDictionary方法NSThread来检索NSMutableDictionary对象，可以在该对象中添加线程所需的任何键。在POSIX中，您可以使用pthread_setspecific和pthread_getspecific函数来设置和获取线程的键和值。

#### 设置线程的分离状态
默认情况下，大多数高级线程技术都会创建分离的线程。在大多数情况下，最好使用分离的线程，因为它们允许系统在线程完成后立即释放线程的数据结构。分离的线程也不需要与程序进行显式交互。从线程中检索结果的方法由您自行决定。相比之下，系统不会回收可连接线程的资源，直到另一个线程与该线程显式连接为止，该过程可能会阻塞执行该连接的线程。

您可以将可连接线程视为类似于子线程。尽管它们仍然作为独立线程运行，但是在系统可以回收其资源之前，可连接线程必须由另一个线程连接。可连接线程还提供了一种显式的方法，可将数据从退出线程传递到另一个线程。在连接退出之前，可连接线程可以将数据指针或其他返回值传递给该pthread_exit函数。然后另一个线程可以通过调用该pthread_join函数来声明此数据。

> 重要：在应用程序退出时，分离的线程可以立即终止，但可连接的线程不能终止。在允许进程退出之前，必须先连接每个可连接线程。因此，在线程正在执行不应中断的关键工作（例如将数据保存到磁盘）的情况下，可连接线程可能更可取。

如果确实要创建可连接线程，则唯一的方法是使用POSIX线程。POSIX默认将线程创建为可连接线程。要将线程标记为分离的或可联接的，请pthread_attr_setdetachstate在创建线程之前使用函数修改线程属性。线程开始后，您可以通过调用pthread_detach函数将可连接线程更改为分离线程。

#### 设置线程优先级
您创建的任何新线程都具有与之关联的默认优先级。内核的调度算法在确定要运行的线程时会考虑线程优先级，与优先级较低的线程相比，优先级较高的线程更有可能运行。较高的优先级并不能保证您的线程有特定的执行时间，只是与较低优先级的线程相比，调度程序更可能选择该时间。

> 重要说明：  通常最好将线程的优先级保留为默认值。增加某些线程的优先级也会增加低优先级线程之间出现饥饿的可能性。如果您的应用程序包含必须相互交互的高优先级和低优先级线程，则低优先级线程的饥饿可能会阻塞其他线程并造成性能瓶颈。

如果您确实想修改线程优先级，那么Cocoa和POSIX都提供了一种方法。对于Cocoa线程，可以使用的``setThreadPriority:class``方法NSThread来设置当前正在运行的线程的优先级。对于POSIX线程，请使用``pthread_setschedparam``函数。

### 编写线程入口程序

在大多数情况下，OS X中线程入口点例程的结构与其他平台上的相同。您可以初始化数据结构，进行一些工作或有选择地设置运行循环，并在线程代码完成后进行清理。根据您的设计，编写输入例程时可能需要执行一些其他步骤。

#### 创建AutoreleasePool
在Objective-C框架中链接的应用程序通常必须在其每个线程中至少创建一个自动释放池。如果应用程序使用托管模型（该应用程序负责对象的保留和释放），则自动释放池将捕获从该线程自动释放的所有对象。

如果应用程序使用垃圾回收而不是托管内存模型，则不一定必须创建自动释放池。垃圾收集应用程序中自动释放池的存在无害，并且在大多数情况下都将被忽略。在代码模块必须同时支持垃圾回收和托管内存模型的情况下，允许使用此方法。在这种情况下，必须存在自动释放池以支持托管内存模型代码，并且如果在启用垃圾回收的情况下运行应用程序，则将自动忽略该释放池。

如果您的应用程序使用托管内存模型，则创建自动释放池应该是您在线程输入例程中要做的第一件事。同样，销毁此自动释放池应该是线程中的最后一件事。该池确保捕获自动释放的对象，尽管它直到线程本身退出才释放它们。清单2-2显示了使用自动释放池的基本线程输入例程的结构。

```C++
- (void)myThreadMainRoutine
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Top-level pool
 
    // Do thread work here.
 
    [pool release];  // Release the objects in the pool.
}
```

#### 设置Exception Handler
如果您的应用程序捕获并处理了异常，则应准备好线程代码以捕获可能发生的任何异常。尽管最好在可能发生异常的地方处理异常，但是未能捕获线程中引发的异常会导致应用程序退出。在线程输入例程中安装最终的try / catch可以捕获任何未知的异常并提供适当的响应。

在Xcode中构建项目时，可以使用C ++或Objective-C异常处理样式。

#### 设置RunLoop
在编写要在单独的线程上运行的代码时，有两个选择。第一种选择是将线程的代码编写为一个很长的任务而几乎不中断执行，也不会中断，并在完成时退出线程。第二种选择是将您的线程置于循环中，并使其在到达请求时动态处理请求。第一个选项不需要为您的代码进行特殊设置。您只需开始做您想做的工作。但是，第二个选项涉及设置线程的运行循环。

OS X和iOS为在每个线程中实现运行循环提供了内置支持。应用程序框架会自动启动应用程序主线程的运行循环。如果创建任何辅助线程，则必须配置运行循环并手动启动它。

### 终止线程
建议的退出线程的方法是让其正常退出其入口点例程。尽管Cocoa，POSIX和Multiprocessing Services提供了直接杀死线程的例程，但强烈建议不要使用此类例程。杀死线程可防止该线程在其自身清除后清理。线程分配的内存可能会泄漏，线程当前正在使用的任何其他资源可能无法正确清理，从而在以后产生潜在的问题。

如果您预计需要在操作过程中终止线程，则应从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到此消息。如果确实有消息要求线程退出，则该线程将有机会执行任何需要的清理并正常退出；否则，它可以简单地返回工作并处理下一个数据块。

响应取消消息的一种方法是使用运行循环输入源接收此类消息。清单2-3显示了该代码在线程的主入口例程中的外观结构。（该示例仅显示了主循环部分，不包括设置自动释放池或配置要执行的实际工作的步骤。）该示例在运行循环上安装了一个自定义输入源，该输入源大概可以从另一个您的线程；有关设置输入源的信息，请参阅配置运行循环源。在完成全部工作量的一部分后，线程会短暂运行运行循环，以查看消息是否到达输入源。如果不是，则运行循环立即退出，并且循环继续进行下一个工作块。因为处理程序无法直接访问exitNow局部变量，所以退出条件通过线程字典中的键值对传达。
```C++
- (void)threadMainRoutine
{
    BOOL moreWorkToDo = YES;
    BOOL exitNow = NO;
    NSRunLoop* runLoop = [NSRunLoop currentRunLoop];
 
    // Add the exitNow BOOL to the thread dictionary.
    NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];
    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@"ThreadShouldExitNow"];
 
    // Install an input source.
    [self myInstallCustomInputSource];
 
    while (moreWorkToDo && !exitNow)
    {
        // Do one chunk of a larger body of work here.
        // Change the value of the moreWorkToDo Boolean when done.
 
        // Run the run loop but timeout immediately if the input source isn't waiting to fire.
        [runLoop runUntilDate:[NSDate date]];
 
        // Check to see if an input source handler changed the exitNow value.
        exitNow = [[threadDict valueForKey:@"ThreadShouldExitNow"] boolValue];
    }
}
```
