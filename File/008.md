# Mach: the core of Apple’s OS X
原链[Mach: the core of Apple’s OS X](https://erichmusick.com/writings/technology/mach-microkernel-osx.html)。

# 介绍
自从 Apple 在 2001 年发布其基于 UNIX 的 Mac OS X 操作系统以来，它已经作为 Windows 的最有可能的替代产品而受到欢迎。尽管许多公司尚未“做出改变”并开始使用这个操作系统，但苹果最近增加了对 Intel 微处理器体系结构的支持，这是又一个吸引人们的步骤。苹果对操作系统结构关键方面的谨慎选择，赋予了操作系统众所周知的稳定性和性能。具体来说，对这些核心 OS X 组件的底层分析表明，选用Mach作为系统内核的核心，在整个操作系统的效率中起到了根本性的作用。

# XNU概述
苹果的 XNU (“X is not Unix”) 内核由三个核心组件组成，它们一起为 Mac OS X 操作系统 [Apple 2006] 提供基本功能。OS X 内核中最知名的组件基于 UNIX 的伯克利标准发行版（BSD）。苹果内核中包含的 BSD 功能主要基于FreeBSD 5.x，提供诸如权限，POSIX 函数的 API、BSD 风格的系统调用和文件系统管理之类的功能。尽管它不如 Mac OS X 的主要组成部分有名，但卡耐基梅隆大学的 Mach 3.0 微内核的衍生版本提供了许多核心内核功能，这些功能是 BSD 衍生部分正常工作所必需的。它执行关键的传统操作系统职责，例如抢先式多任务处理、内存管理、进程间通信、内核调试，和控制台输入和输出。XNU内核的第三个组件是I / O套件，它通过基于嵌入式 C++ 的语言提供面向对象的设备驱动程序控制[Singh 2006]。


# 内核模型

在操作系统世界中，有两类内核：宏内核和微内核。顾名思义，它们的主要区别在于它们的大小，以及因此所包含的操作系统功能的范围[Galli 2000]。

## 宏内核
一本教科书将其描述为“大混乱”，整体内核的结构可以称之为“没有结构”。[Tanenbaum 2001]。宏内核包含大多数（即使不是全部）操作系统能力，处理进程、内存、文件、名称和设备管理[Galli 2000]。它缺乏保护边界，并且不封装任何功能[Tanenbaum 2001] —— 任何功能都可以引用任何其他功能或任何数据。由于其庞大的代码库和缺乏组织性，宏内核通常难以调试、验证和修改。他们缺乏模块化，使得它们不适合用于分布式计算，因为每个系统仅完成所有必需任务的选择，而每个系统却包含了整个代码库[Galli 2000]。

## 微内核
微内核在操作系统设计中采用了更加模块化的客户端/服务器方法。大多数功能已从内核中删除，因此只剩下剩余的小内核来完成内核处理。取而代之的是，将删除的功能实现为用户级流程。内核介导这些客户端进程和服务器之间的通信，例如那些有助于文件 I/O 或提供对内存的访问的服务器。内核对服务器访问权限的限制提供的封装有助于最大程度地减少错误的影响[Tanenbaum 2001]。如果直接修改内核控制的变量（例如过程控制块）而导致的错误可能导致整个基于内核的整体系统崩溃，

基于微内核的操作系统体系结构固有的模块化性导致了更易于管理的部分，并且非常适合于分布式系统，其中在一个系统上运行的客户端从另一个系统上的服务器请求数据。从客户端的角度来看，无论服务器是本地服务器还是远程服务器，“相同的事情都会发生” –“发送请求并返回回复”（Tanenbaum 2001）。

在许多微内核中，特定于计算机体系结构的特定功能都保存在单个模块中。因此，内核可以根据需要移植到新架构，而无需完全重写。而是可以简单地插入现有模块或编写新模块来满足新体系结构的需求[Galli 2000]。

#  Mach微内核 

## 概述和历史
Mach 最初是由卡内基梅隆大学计算机科学系在 1980 年代中期开发的，是单线程内核[Singh 2006]。Mach v2.5 最初旨在用作 BSD 4.2 的内核，但它将大多数 BSD 功能实现为单个内核线程。由于它不是多线程的，因此其效率受到限制。随着代码库的增大，BSD 功能从内核中提取出来，并以真正的微内核方式放置在外部库中。内核中保留的内容被用作 Mach 3.0 的基础。由于特定于操作系统的 BSD 代码已移出内核并进入用户级进程，因此 Mach 微内核只是充当基础层，可以在其上构建不同的操作系统[Silberschatz和Galvin 1993]。

Mach 微内核的主要目标之一是“成为一个能够在异构硬件上运行的分布式系统”。因此，它提供了支持1到1000个处理器之间的系统的规定，并且其编写目的是为了便于修改，使其可以在多种计算机体系结构上运行。由于它起源于 BSD ，因此它在功能上也与 BSD 4.3 完全兼容，因此是 Apple OS X 内核的不错选择，在 OS X 内核中 BSD 也起着基本作用[Silberschatz和Galvin 1993]。

## 设计哲学
Mach 开发人员除了为各种厂商构建的各种单处理器和多处理器计算机体系结构提供支持外，还旨在限制核心抽象的数量。将这几个元素用于几乎所有操作系统功能，可避免不必要的代码重复并保持合理的大小。它还支持内置在内核中的内存管理和进程间通信功能，并使所有其他关键操作系统功能可以在广泛的体系结构以及它们使用的计算机网络上工作。另外，UNIX 开发背后的许多哲学，例如易于使用的 API，庞大的实用程序和应用程序库以及对管道的利用，都影响了 Mach 体系结构的方法[Silberschatz和Galvin 1993]。

尽管它起源于 BSD、UNIX，并受到 BSD、UNIX 的严重影响，但是 Mach 的开发人员试图避免 UNIX 的某些负面影响和错误。例如，UNIX 中存在大量冗余，并且它对多处理器系统的支持并非最佳。另外，Mach 尝试采用 UNIX 的大量抽象并将其进一步抽象化，以创建最小集，同时仍提供内核的所有必要功能[Silberschatz和Galvin 1993]。

## 抽象
开发 Mach 内核所依据的理念使得内核“在执行类似任务时与 UNIX 的其他主要版本一样高效”。通过提供以下六个基本抽象来实现此性能：[Silberschatz and Galvin 1993]

* 任务    
        在操作系统理论中通常称为进程，一个Mach任务是“基本组织实体” [Kutrtzman and Dattatri 1995]，具有自己的存储空间。一个任务本身无法执行，而是包含一个或多个线程与之共享资源[Silberschatz and Galvin 1993]。
* 线程    
        线程的Mach概念与其他现代多线程操作系统中的线程概念几乎没有什么不同，可以被视为“系统中的可执行实体”。线程具有其自己的寄存器和调度策略，并且只能在任务上下文中存在[Kutrtzman和Dattatri 1995]。
* 端口    
        Mach利用端口作为内核控制的双向通信通道。为了通过这些通道发送或接收数据，线程必须具有访问权限，称为端口权限 [Silberschatz and Galvin 1993]。
* 端口集    
        顾名思义，端口集是利用相同消息队列的端口的集合。每个任务都与单个端口集相关联。通过允许线程同时通过多个端口发送或接收消息，这有助于提高效率[Silberschatz and Galvin 1993]。
* 消息    
        Mach中的消息是最小的通信单元，包含在线程之间传输的数据[Silberschatz和Galvin 1993]。
* 内存对象    
        内存对象由“可字节寻址的数据……由……外部内存管理器管理” [Kutrtzman and Dattatri 1995]。任务创建对Mach内存对象的引用，以便从内存访问数据[Silberschatz和Galvin 1993]。

## 调度

按照其哲学，Mach微内核在其调度方法中为对称多处理作了准备。线程执行具有优先级，并通过一组运行（就绪）队列提供支持，该队列由几个本地，每个处理器队列和一个全局，系统范围的队列组成。这些运行队列的下面是一个数据结构，其中包含32个双链接的优先队列[Black 1990]。有趣的是，随着对全局就绪队列的更改，内核将其锁定，以防止由多个处理器发起的同时修改引起的冲突[Silberschatz and Galvin 1993]。

在较早版本的Mach中，就绪队列将托管线程的优先级设置为 0-127 。此后进行了修改，以更紧密地关联线程优先级和就绪队列的数量。因此，优先级现在为 0-31 [Black 1990]，它们对线程的分配基于两个因素：“基准”值和反映历史 CPU 使用率的偏移量[Galli 2000]。为了防止饥饿，Mach 每两秒钟增大一次线程优先级[Black 1990]。

为了帮助消除调度效率低下的问题，Mach允许线程向内核提供两种类型的提示。每个对象的设计目标都是赋予优先级较低的进程更大的机会安排到CPU上。例如，这在已知较低优先级的进程必须先执行某些功能才能继续执行较高优先级的进程时很有用。劝阻提示具有三种优势-温和，强和绝对-并减少了给出提示的进程将被切换到处理器的可能性。绝对不鼓励使用的提示会阻止发出提示的线程在指定的时间内放置在CPU上。强提示减少线程自己的优先级，而温和提示只是“建议” CPU避免调度线程。另一方面，切换提示

每个处理器都有自己的调度程序。当确定接下来要放置在处理器上的线程时，调度程序将首先查询其自己的本地运行队列。如果没有准备好要执行的进程，它将从全局的系统级运行队列中选择并执行优先级最高的进程。本地队列中的线程绑定到它们驻留在其就绪队列中的处理器。例如，连接到处理器1的硬件的设备驱动程序只能通过处理器1的运行队列进行调度，因为它是唯一可以直接与该硬件设备通信的处理器[Silberschatz and Galvin 1993]。

调度程序从本地或全局运行队列中选择了最高优先级的进程后，便为其分配一个时间片。每10到100毫秒，就会发生一次中断，并且调度程序将减少分配给执行进程的时间片。当线程没有剩余时间时，内核上下文将切换到准备执行的下一个进程，或者将当前进程留在CPU上，具体取决于哪个进程具有更高的优先级[Black 1990]。

## 进程间通信
在UNIX中，进程和系统之间的通信取决于位置。发件人必须知道收件人的姓名才能正确处理该消息。另一方面，Mach则采用了与位置无关的“面向对象”方法进行进程间通信[Silberschatz and Galvin 1993]。

所有通信-无论是在两个线程，一个线程和内存，两个不同的系统之间，还是在一个线程和内核之间-都可以看作是通过两个关键的Mach抽象促进的两个对象之间的信息传递。每个对象在端口上都收到消息形式的指令[Silberschatz和Galvin 1993]。为了在端口上发送或接收消息，线程的任务必须具有适当的权限。这些端口权限包括发送，一次发送，接收，端口集和无效名称。就像已经结束的过程进入“终止”状态一样，被破坏的端口的权利也变成了“死名”。一次发送权利，顾名思义，允许消息的接收者一次通过端口将数据发送回发送者。

通过这些内核控制的消息队列发送的消息由两个主要部分组成-标头和数据部分。标头指定目标端口（应将任何必要的响应发送到该端口）以及数据的长度。Mach消息的数据段包含多个数据对象。在Mach 2.5中，这些数据对象的总大小限制为8 KB，但在3.0版中已删除了该限制。数据对象具有各种形状和大小，包括端口权限，数字形式的原始数据以及指向内存中数据的指针。这些指向内存中数据的指针“提供了在一条消息中传输任务的整个地址空间的手段。” 当使用这些指针发送大量数据时，内核会根据需要启动，并有助于数据的传输。

由于端口是作为内核的一部分实现的，因此该功能的所有利用都必须由内核来调解，这将强制执行端口权限。由于端口功能与任何用户级别的过程都安全地分开了，因此可以最大程度地降低尝试干扰通信的任务的风险。内核对整个通信过程的监督可以防止消息被“伪造，误导或伪造” [Kutrtzman and Dattatri 1995]。

Mach的多合一通信方法，利用一种技术进行消息的所有传输，增强了对多处理和网络通信的支持。它进一步展示了提供最小，最快的内核的关键 Mach 哲学。进程间通信通常可能很慢，但是像Mach一样，在操作系统的核心实现它有助于提高速度。另外，由于仅存在一种通信方法，因此可以花费大量的精力来优化它，而不是开发几种效率较低的方法[Silberschatz and Galvin 1993]。

## 内存管理 
内存对象是 Mach 微内核的另一个关键抽象，其行为类似于系统中存在的其他对象。他们也利用Mach强大的进程间通信，并使用管道和消息传输数据。这种实现方法还使开发人员可以轻松地尝试各种内存处理算法[Silberschatz和Galvin 1993]。

Mach 的虚拟地址空间可寻址4 GB以上的数据。该地址空间不仅在一个连续的内存区域中而且在页面中分配给所有任务。分页是内存管理的行业标准方法，通常可确保内存的最佳利用。正如对操作系统理论有基本了解的人所期望的那样，任务中的所有线程都共享相同的内存。当父线程派生一个子代时，指定此共享的范围。父母可以向孩子授予其内存空间的副本，也可以向其直接读写父母空间的原始空间的权限。但是，Mach并不能为解决单个任务中多个线程之间的冲突内存写入提供任何帮助。而是

尽管内存管理不依赖于内核-提供了用于管理内存对象的用户进程-但Mach确实为此类功能提供了大量支持。因为Mach的内核有其自己的内存需求，并且并非所有基于用户的内存管理器都执行内核访问内存所需的所有功能，所以Mach提供了默认的内存管理器。它利用Pageout技术，该技术利用FIFO的优势和第二次机会实现。除了支持内核对内存的访问之外，默认内存管理器的一个主要目的是解决同时请求修改同一内存位置的问题[Silberschatz and Galvin 1993]。


#  Mach 在 XNU 中的作用的思考
苹果发烧友和作家丹·奈特（Dan Knight）在题为“ OS X压制Mac”的文章中称，Mach 是操作系统的“致命弱点”。根据这一判断，他建议苹果放弃在OS X内核中使用Mach，而转而使用基于Linux的整体内核。他引用维基百科有关微内核的文章，声称“微内核效率低下，因为操作系统的不同部分之间发生了所有通信” [2005]。奈特的建议是基于错误的假设，即OS X实际上将Mach实施为微内核而没有任何修改。苹果在将UNIX / Linux应用程序移植到OS X的文档中提醒开发人员，尽管“ XNU基于Mach微内核设计，”它还包括BSD功能，因此“从技术上讲不是微内核实现。” 苹果甚至竭力解决奈特指出的特定问题，并承认微内核与其上层之间的通信会导致性能下降。但是，可以通过结合XNU内核[2006]中的“ Mach的优势与BSD的优势”来解决此问题。

但是，奈特的主张很有趣。随着苹果公司最近转向基本符合行业标准的英特尔架构，不无道理地建议奈特有理由认为OS X的其他方面可以从变更中受益。挑战在于寻找在何处以及如何进行此类增强。尽管Mach提供的坚实基础不可能一时被取代，但是只有时间才能证明这些改进是最好的对现有XNU内核的优化，还是最好通过重新设计内核来获得。


# 结论
将Mach微内核的变体置于Mac OS X核心的选择为该操作系统成为许多人认为是目前功能最强大的面向消费者的操作系统提供了基础。Mach对效率的强调是通过使用少量核心抽象和优化一种通信方法来实现的，这为Mac OS X的成功做出了贡献。此外，Mach的体系结构独立性为其过去的普及和广泛使用做出了贡献二十年来，苹果公司还使苹果公司能够最近转换到英特尔架构。尽管在OS X的XNU内核中使用Mach的决定可能会遇到挑战，但其悠久的历史和多年的发展使其成为核心的可能性已不大可能。

# 参考文献
[Apple 2006]将UNIX / Linux应用程序移植到Mac OS X，Apple Computer，Inc.，http：//developer.apple.com/documentation/Porting/Conceptual/PortingUnix/index.html（2006）。

[Black 1990] DL Black，“在Mach操作系统中调度对并发和并行性的支持”，计算机，第23卷，第5期（1990年5月），第35-43页。

[Galli 2000] DL Galli，《分布式操作系统–概念与实践》，Prentice Hall，Inc.（2000）。

[Knight 2005] D. Knight，“ OS X阻碍了Mac的发展”，Low End Mac，http：//lowendmac.com/musings/05/1214.html（2005）。

[Kutrtzman and Dattatri 1995] S. Kurtzman和K. Dattatri，“面向Mach微内核的面向对象包装器的设计目标” ，第40 届 IEEE计算机学会国际会议论文集（1995），第367-371页。

[Silberschatz and Galvin 1993] A. Silberschatz，PB Galvin，“Mach 系统”，《操作系统原理》，第四版，Addison-Wesley，Inc.（1993），第897-921页。

[Singh 2006] A. Singh，“什么是Mac OS X？– XNU：内核，” kernelthread.com，http：//www.kernelthread.com/mac/osx/arch_xnu.html（2006）。

[Tanenbaum 2001] AS Tanenbaum，《现代操作系统》，第二版，Prentice Hall，Inc.（2001）。