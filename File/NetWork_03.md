# 伯阳的网络笔记（四）：TCP 
> 因为疫情期间在外当志愿者，晚上回家无聊翻翻网络知识，权当记录了。
> 初始动笔：2019-02-11
> 修改时间：2019-04-01

# 1. TCP是什么？
互联网有两个核心协议： IP 和 TCP。IP，即 Internet Protocol（因特网协议）负责联网主机之间的路由选择和寻址；TCP，即 Transmission Control Protocol（传输控制协议）。

TCP 负责在不可靠的传输信道上提供可靠的抽象，向应用层隐藏了大多数网络通信的复杂细节。采用 TCP 数据流可以确保发送的所有字节都能够完整的被接收到，而且到达客户端的顺序也一样。一般来说， HTTP 协议是基于 TCP 的，但也不绝对，实际上已经有人用 UDP 来搞定 HTTP 了。

我们可以这么说，HTTP 协议专注于要传输的信息，TCP 协议专注于确保传输的可靠，而IP则负责因特网传输。
# 2. TCP 首部格式
首部格式如图所示：
![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_17.png?raw=true)

它的标准长度是20字节。TCP 中没有单独的字段表示包长度和数据长度。可由 IP 层获知 TCP 的包长，由 TCP 的包长可知数据的长度。

* 序列号 (Sequence Number):
        字段长 32 位，序列号是指发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。序列号不会从0 或者 1 开始，而是在建立连接的时候由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机。

* 确认应答号 (Acknowledgement Number)：
        确认应答号字段长度为 32 位。是指下一次应该收到的数据的序列号，实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经正常接收了。ACK=1 时有效。

* 数据偏移 (Data Offset)
        该字段表示 TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算，当然也可以把它看作 TCP 首部的长度。该字段长 4 位，单位为 4 字节 (即 32 位)。不包含选项字段的话，数据偏移字段可以设置为 5 。反之，如果该字段的值为 5，那说明从 TCP 包的最一开始到 20 字节为止都是 TCP 首部，余下的部分为 TCP 数据。

* 保留 (Reserved):
        该字段主要是为了以后扩展使用，其长度为 4 位，一般设置成 0 ，即使收到的包在该字段不为 0 ，此包也不会被丢弃。

*   控制位 (Control Flag):
        字段长为 8 位，从左往右分别如下图：
![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_18.png?raw=true)

* 校验和 (Checksum):
        TCP 的校验和和 UDP 的相似，区别在于 TCP 的校验和无法关闭（UDP 可以在校验和字段填 0 ，来关闭校验）与 UDP 数据报一样，TCP 数据报段在计算校验和时也包括一个 12 字节长的伪首部。
        
* 紧急指针：
        该字段为 16 位，只有在 URG 控制位为 1 的时候有效。该字段的数值表示本报文段中紧急数据的指针。

* 选项：
        选项字段用于提高 TCP 的传输性能，因为根据数据偏移（首部长度）进行控制，所以其长度最大为 40 字节。另外，选项字段尽量调整其为 32 位的整数倍。

## 控制位

控制位的细节如下。

1. CWR (Congestion Window Reduced)：
        CWR 标志和后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 字段为 1 时，则通知对方已将拥塞窗口缩小。

2. ECE (ECN-Echo):
        ECE 标志表示 ECN-Echo。置为 1 ，代表会通知对方，从对方到这边的网络有拥塞。

3. URD (Urgent Flag):
        该位为1，代表包中有需要紧急处理的数据。

4. ACK (Acknowledgement Flag):
        该位为1，代表确认应答的字段变有效。

5. PSH (Push Flag):
        该位为1，表示需要将受到的数据立即传给上层应用协议。为 0 表示不用立即传，先进行缓存。

6. RST (Reset Flag):
        该位为1，表示 TCP 连接中出现异常必须强制断开连接。

7. SYN (Synchronize Flag):
        为1表示希望建立连接，并在其序列号字段进行序列号的随机初始值的设定。

8. FIN (Fin Flag):
        该位为1，表示今后再也没有数据发送了，希望断开连接。



# 3. TCP 三次握手
所有的 TCP 连接一开始都要经过三次握手，如下图所示。客户端在于服务器在交换应用数据之前，必须就起始分组序列号，以及其他一些连接相关的细节达成一致。处于安全考虑，序列号由两端随机生成。
![](https://github.com/BiBoyang/BoyangBlog/blob/master/Image/NetWork_19.png?raw=true)

1. 第一次握手(SYN=1， seq=x):
        客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里。序列号的实现目前会随着时间的变化而变化，所以每次建立连接时的序列号都不同
        发送完毕后，客户端进入 SYN_SEND 状态。

1. 第二次握手(SYN=1， ACK=1， seq=y， ACKnum=x+1):
        服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN（init SEQ num） 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

3. 第三次握手(ACK=1，ACKnum=y+1)
客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
        发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

三次握手完成之后，客户端与服务器之间就可以通信了。客户端在发送 ACK 分组之后立即发送数据，而服务器必须等到受到 ACK 分组之后才能发送数据。这个启动通信的过程适用于所有 TCP 连接，因此对所有使用 TCP 的应用具有非常大的性能影响。

三次握手带来的延迟是的每创建一个新的 TCP 连接都要付出很大的代价，而这也决定了提高 TCP 应用性能的关键，在于想办法**重用连接**。


## 为什么是“三次”
我们可以很明显的发现，只要两次其实就可以开始连接了，为什么要多出来第三次呢（你别问为什么不四次五次，要考虑性能的好伐）？

事实上我们可以这么说，只有两次握手，可以保证连接成功，而第三次的握手是用来声明双方的连接是正常的。

我们要明白，网络环境是不稳定的，尤其是在几十年前。我们可以想象这样一个画面：客户端发出一个连接请求，但是很久没有收到消息，所以又发送了一个连接请求，但是第一个请求因为网络拥塞延迟到达，甚至在服务器接收第二个请求然后发送消息了之后才到达。

我们知道请求的序列号其实是随机的，那么服务器实际上是没法知道这两个的先后顺序。

所以，将第二次握手的数据发送过去的**序列号+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1**是非常重要的，这样保证了不会浪费资源多次请求。

### RST
RST (Reset Flag): 该位为1，表示 TCP 连接中出现异常必须强制断开连接。

TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接：
* 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接；
* 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接；

### 序列号
再说一次，网络是不稳定的，即使建立了连接，发送的消息也有可能在接收的时候顺序颠倒。为了重新排序以及去重，这里引入了序列号这个概念。

序列号的初始化需要在三次握手的时候进行初始化。由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 SYN 控制消息并携带自己期望的初始化序列号 SEQ，对方在收到 SYN 消息之后会通过 ACK 控制消息以及 SEQ+1 来进行确认。


## 握手的时候可以带数据
曾经抓包的时候，发现 TCP 的第三次握手是可以带数据的，然后查阅资料后发现，这个其实非常正常，是个常见情况。不过随着我继续深入的查阅，很惊讶的发现，其实第一次握手也是可以带数据的！！！

原始TCP标准[RFC 793](https://tools.ietf.org/html/rfc793)确实允许与第一个SYN数据包一起发送数据，作为握手的一部分，但是在握手完成之前，此类数据无法释放。大多数传统的 TCP 编程接口都不支持此早期数据选项。




# 4. TCP 拥塞控制 & 流量控制
第三次说：网络是不稳定的！
如果网络出现拥塞（比较常见的是我们称之为弱网的情形），分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率，这是**拥塞控制**。

而网络情况突然好的不得了，一堆数据一拥而上，也会有问题。事实上，接收方也许正在忙于其他任务，甚至要过很长时间才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送的太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。这个也需要控制，这个控制就是**流量控制**。

很多人会将这两者混淆，但是要明白，虽然这两者的动作非常相似（对发送方的遏制），但是它们显然是针对完全不同的场景而采取的措施。

因为这两者的动作非常类似，可以统一的来说。TCP 主要使用四种方法：**慢启动**、**拥塞避免**、**快重传**、**快恢复**。发送方需要维护一个叫做**拥塞窗口（Congestion Window-cwnd）**的状态变量。

## 慢启动 和 拥塞避免
TCP 协议使用慢启动阈值（Slow start threshold, ssthresh）来决定使用慢启动或者拥塞避免算法：

* 当拥塞窗口大小小于慢启动阈值时，使用慢启动；
* 当拥塞窗口大小大于慢启动阈值时，使用拥塞避免算法；
* 当拥塞窗口大小等于慢启动阈值时，使用慢启动或者拥塞避免算法；

慢启动实际上指的是一个启动的过程：
1. 最开始 cwnd=1，发送方只发送一个 MSS（最大报文段长度）大小的数据包，在一个 RTT 后，会收到一个 ACK ，cwnd 加一，cwnd=22.
2. 此时 cwnd=2，则发送方要发送两个 MSS 大小的数据包，发送方会收到两个 ACK，则 cwnd 会进行两次加一的操作，则也就是 cwnd+2，则 cwnd=4，也就是 cwnd = cwnd * 2
3. 此时 cwnd=4，则发送方要发送四个 MSS 大小的数据包，发送方会收到四个 ACK ，则 cwnd会加4，则 cwnd = 8，也就是 cwnd = cwnd * 2.

一旦发现当发送方发送的数据包丢包时，就会开始拥塞避免算法：
* 慢启动阈值会设置为拥塞窗口大小的一半；








# TCP 流量控制

# TCP洪泛攻击

# 保活机制



# 引用
[RFC791](https://tools.ietf.org/html/rfc791)

[RFC793](https://tools.ietf.org/html/rfc793)

[为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake/)
[《An Introduction to Computer Networks:12.TCP Transport》](http://intronetworks.cs.luc.edu/current/html/tcp.html#tcp-transport)

《Web权威性能指南》

《计算机网络》

《计算机网络：自顶向下方法》